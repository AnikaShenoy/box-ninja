{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/natalievolk/Desktop/box-ninja-anika/box-ninja/box-ninja-site/src/components/Game.js\";\nimport React from 'react';\nimport * as THREE from 'three.js';\n\nconst Game = () => {\n  function main() {\n    const canvas = document.querySelector('#c');\n    const renderer = new THREE.WebGLRenderer({\n      canvas,\n      antialias: true\n    }); // NOTE: if we didn't pass 'canvas' as an argument to WebGLRenderer (above),\n    // then we would have to set size and add renderer to HTML document:\n    //      renderer.setSize(window.innerWidth, window.InnerHeight);\n    //      document.body.appendChild(renderer.domElement);\n    // trying to make raycaster work\n\n    var raycaster = new THREE.Raycaster();\n    let intersectedBox; // points keeper\n\n    var points = 0; // REMOVE when implementing handtrack\n\n    document.addEventListener('mousemove', onDocumentMouseMove, false); // need 3 things to display with three.js --> scene, camera, renderer\n    // create a new scene\n\n    var scene = new THREE.Scene(); // creating a directional light to give box definition\n\n    const color = 0xFFFFFF;\n    const intensity = 1;\n    const light = new THREE.DirectionalLight(color, intensity); // directional lights have a position and target --> default of both is (0,0,0)\n    // setting position to (-1,2,4) --> left, above, and behind our camera\n    // leaving target as default (so it will shine to origin)\n\n    light.position.set(-1, 2, 4);\n    scene.add(light); // PerspectiveCamera mimics the way humans see a scene\n    // 75 --> FOV (in degrees)\n    // IW/IH --> aspect ratio\n    // 0.1 --> near, 500 --> far; this means that objects closer / farther won't be rendered\n\n    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500); // moving camera out in z-plane\n\n    camera.position.z = 5; // function that makes a new material with  specified geometry, color, \n    //  and x- and y-coordinates\n\n    function makeShape(geometry, color, coordinates) {\n      // often, we'd use:\n      //      var material = new THREE.MeshBasicMaterial({color: 0x00ff00});\n      // but, we need to use MeshPhongMaterial, which is affected by lights\n      const material = new THREE.MeshPhongMaterial({\n        color\n      }); // mesh is an object that takes geometry and material objects which can be inserted into scene\n\n      const cube = new THREE.Mesh(geometry, material);\n      scene.add(cube); // by default, object is added to coordinates (0,0,0), but can be changed:\n\n      cube.position.x = coordinates[0];\n      cube.position.y = coordinates[1];\n      cube.position.z = -10;\n      return cube;\n    } // REMOVE when implemented handtrack\n    // create mouse vector and track movement\n\n\n    const mouse = new THREE.Vector2();\n\n    function onDocumentMouseMove(event) {\n      event.preventDefault();\n      mouse.x = event.clientX / window.innerWidth * 2 - 1;\n      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n    } // FONTS FOR POINT TOTAL --> should work once multi-page website is made\n    // SOURCE: https://threejs.org/docs/#api/en/geometries/TextGeometry\n\n    /*\n    function printPoints(points) {\n       const loader = new THREE.FontLoader();\n        let text = \"Points: \" + points;\n        loader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {\n           const geometry = new THREE.TextGeometry(text, {\n                font: font,\n                size: 10,\n                height: 5,\n                curveSegments: 12,\n                bevelEnabled: true,\n                bevelThickness: 10,\n                bevelSize: 8,\n                bevelOffset: 0,\n                bevelSegments: 5\n          } );\n       } );\n    }\n    */\n    // creating the cube geometry\n\n\n    var geometry = new THREE.BoxGeometry(1, 1.2, 1); // array to randomize colours for the cubes\n\n    var colours = [0x8844aa, 0x4deeea, 0x74ee15, 0xffe700, 0xf000ff, 0x001eff, 0xFF0000, 0xC724B1, 0xfeaf2f, 0xfe17a2, 0x40e0d0]; // array to randomize speeds for the cubes \n\n    var speeds = [0.1, 0.15, 0.2, 0.12, 0.18, 0.19, 0.15, 0.13]; // array to append cubes as needed\n\n    var cubes = [makeShape(geometry, colours[Math.floor(Math.random() * 11)], [0, 0])]; // this creates a loop that will keep on rendering the app everytime the page refreshes\n\n    function render(time) {\n      // time is given in milliseconds (ms)\n      time *= 0.001; // convert time from milliseconds to seconds\n      // randomly generate colour for the cube\n\n      var colour = colours[Math.floor(Math.random() * 10)]; //TODO: decide on which way of randomizing cubes is better\n      //option 1:\n      // these if-statements \"randomly\" generate the cubes and the cube's location\n      //  since based on time, the intervals are more even\n\n      if (time % 5 < 0.02) {\n        cubes.push(makeShape(geometry, colour, [Math.random() * 5, Math.random() * 2.5]));\n      } else if (time % 4 < 0.02) {\n        cubes.push(makeShape(geometry, colour, [Math.random() * -5, Math.random() * -2.5]));\n      } else if (time % 3 < 0.02) {\n        cubes.push(makeShape(geometry, colour, [Math.random() * -5, Math.random() * 2.5]));\n      } else if (time % 2 < 0.02) {\n        cubes.push(makeShape(geometry, colour, [Math.random() * 5, Math.random() * -2.5]));\n      } // option 2:\n      // since this is truly random, intervals can be uneven\n\n      /*\n      var random = Math.random() / 1.5;\n      if (random < 0.001) {\n         cubes.push(makeShape(geometry, colour, [Math.random()*5, Math.random()*2.5]));\n      }\n      else if (random > 0.001 && Math.random() < 0.002) {\n         cubes.push(makeShape(geometry, colour, [Math.random()*-5, Math.random()*-2.5]));\n      }\n      else if (random > 0.002 && Math.random() < 0.003) {\n         cubes.push(makeShape(geometry, colour, [Math.random()*-5, Math.random()*2.5]))\n      }\n      else if (random > 0.003 && Math.random() < 0.004) {\n         cubes.push(makeShape(geometry, colour, [Math.random()*5, Math.random()*-2.5]))\n      }\n      */\n      // this sets the speed of each cube (because we're translating it by a bit\n      //  in each frame)\n\n\n      cubes.forEach((cube, index) => {\n        // => is just a way to shorten the syntax\n        // speed is randomly chosen from the array of possible speeds\n        cube.translateZ(speeds[Math.floor(Math.random() * 8)]);\n      }); // setting up raycaster and finding intersections (where mouse vector intersects with box)\n\n      raycaster.setFromCamera(mouse, camera);\n      const intersects = raycaster.intersectObjects(scene.children);\n      console.log(intersects);\n\n      if (intersects.length > 0) {\n        // when mouse is over the box, it lights up and is removed from scene\n        if (intersectedBox != intersects[0].object) {\n          intersectedBox = intersects[0].object; // box lights up\n\n          intersectedBox.material.emissive.setHex(0xff0000);\n          intersectedBox.currentHex = intersectedBox.material.emissive.getHex();\n          intersectedBox.material.color.setHex(0xFFFFFF); // after 15ms, box is removed from scene\n\n          setTimeout(() => {\n            scene.remove(intersectedBox);\n          }, 15); // increase points by 10\n\n          points += 10;\n          console.log(points);\n        }\n      } else {\n        if (intersectedBox) intersectedBox.material.emissive.setHex(intersectedBox.currentHex); // set intersected box to null\n\n        intersectedBox = null;\n      } //printPoints(points);\n      // this actually draws the scene\n\n\n      renderer.render(scene, camera);\n      requestAnimationFrame(render);\n    }\n\n    requestAnimationFrame(render);\n  }\n\n  main();\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Box Ninja | Game Page\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 229,\n      columnNumber: 10\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 228,\n    columnNumber: 7\n  }, this);\n};\n\n_c = Game;\nexport default Game;\n\nvar _c;\n\n$RefreshReg$(_c, \"Game\");","map":{"version":3,"sources":["/Users/natalievolk/Desktop/box-ninja-anika/box-ninja/box-ninja-site/src/components/Game.js"],"names":["React","THREE","Game","main","canvas","document","querySelector","renderer","WebGLRenderer","antialias","raycaster","Raycaster","intersectedBox","points","addEventListener","onDocumentMouseMove","scene","Scene","color","intensity","light","DirectionalLight","position","set","add","camera","PerspectiveCamera","window","innerWidth","innerHeight","z","makeShape","geometry","coordinates","material","MeshPhongMaterial","cube","Mesh","x","y","mouse","Vector2","event","preventDefault","clientX","clientY","BoxGeometry","colours","speeds","cubes","Math","floor","random","render","time","colour","push","forEach","index","translateZ","setFromCamera","intersects","intersectObjects","children","console","log","length","object","emissive","setHex","currentHex","getHex","setTimeout","remove","requestAnimationFrame"],"mappings":"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","sourcesContent":["import React from 'react';\nimport * as THREE from 'three.js';\n \nconst Game = () => {\n   function main() {\n      const canvas = document.querySelector('#c');\n      const renderer = new THREE.WebGLRenderer({canvas, antialias: true});\n\n      // NOTE: if we didn't pass 'canvas' as an argument to WebGLRenderer (above),\n      // then we would have to set size and add renderer to HTML document:\n      //      renderer.setSize(window.innerWidth, window.InnerHeight);\n      //      document.body.appendChild(renderer.domElement);\n\n      // trying to make raycaster work\n      var raycaster = new THREE.Raycaster();\n      let intersectedBox;\n\n      // points keeper\n      var points = 0;\n\n      // REMOVE when implementing handtrack\n      document.addEventListener( 'mousemove', onDocumentMouseMove, false );\n\n      // need 3 things to display with three.js --> scene, camera, renderer\n      // create a new scene\n      var scene = new THREE.Scene();\n\n      // creating a directional light to give box definition\n      const color = 0xFFFFFF;\n      const intensity = 1;\n      const light = new THREE.DirectionalLight(color, intensity);\n\n      // directional lights have a position and target --> default of both is (0,0,0)\n      // setting position to (-1,2,4) --> left, above, and behind our camera\n      // leaving target as default (so it will shine to origin)\n      light.position.set(-1, 2, 4);\n      scene.add(light);\n\n      // PerspectiveCamera mimics the way humans see a scene\n      // 75 --> FOV (in degrees)\n      // IW/IH --> aspect ratio\n      // 0.1 --> near, 500 --> far; this means that objects closer / farther won't be rendered\n      var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);\n      // moving camera out in z-plane\n      camera.position.z = 5;\n\n\n      // function that makes a new material with  specified geometry, color, \n      //  and x- and y-coordinates\n      function makeShape(geometry, color, coordinates) {\n         // often, we'd use:\n         //      var material = new THREE.MeshBasicMaterial({color: 0x00ff00});\n         // but, we need to use MeshPhongMaterial, which is affected by lights\n         const material = new THREE.MeshPhongMaterial({color})\n\n         // mesh is an object that takes geometry and material objects which can be inserted into scene\n         const cube = new THREE.Mesh(geometry, material);\n         scene.add(cube);\n\n         // by default, object is added to coordinates (0,0,0), but can be changed:\n         cube.position.x = coordinates[0];\n         cube.position.y = coordinates[1];\n         cube.position.z = -10;\n\n         return cube;\n      }\n\n      // REMOVE when implemented handtrack\n      // create mouse vector and track movement\n      const mouse = new THREE.Vector2();\n      function onDocumentMouseMove( event ) {\n\n         event.preventDefault();\n\n         mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n         mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n      }\n\n      // FONTS FOR POINT TOTAL --> should work once multi-page website is made\n      // SOURCE: https://threejs.org/docs/#api/en/geometries/TextGeometry\n      /*\n      function printPoints(points) {\n         const loader = new THREE.FontLoader();\n\n         let text = \"Points: \" + points;\n\n         loader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {\n\n            const geometry = new THREE.TextGeometry(text, {\n                  font: font,\n                  size: 10,\n                  height: 5,\n                  curveSegments: 12,\n                  bevelEnabled: true,\n                  bevelThickness: 10,\n                  bevelSize: 8,\n                  bevelOffset: 0,\n                  bevelSegments: 5\n            } );\n         } );\n      }\n      */\n\n      // creating the cube geometry\n      var geometry = new THREE.BoxGeometry(1, 1.2, 1);\n      // array to randomize colours for the cubes\n      var colours = [\n         0x8844aa,\n         0x4deeea,\n         0x74ee15,\n         0xffe700,\n         0xf000ff,\n         0x001eff,\n         0xFF0000,\n         0xC724B1,\n         0xfeaf2f,\n         0xfe17a2,\n         0x40e0d0\n      ];\n      // array to randomize speeds for the cubes \n      var speeds = [\n         0.1,\n         0.15,\n         0.2,\n         0.12,\n         0.18,\n         0.19,\n         0.15,\n         0.13\n      ];\n      // array to append cubes as needed\n      var cubes = [\n         makeShape(geometry, colours[Math.floor(Math.random()*11)], [0,0]),\n      ];\n      \n      // this creates a loop that will keep on rendering the app everytime the page refreshes\n      function render(time) { // time is given in milliseconds (ms)\n         time *= 0.001 // convert time from milliseconds to seconds\n\n         // randomly generate colour for the cube\n         var colour = colours[Math.floor(Math.random()*10)];\n\n\n//TODO: decide on which way of randomizing cubes is better\n         \n      //option 1:\n         // these if-statements \"randomly\" generate the cubes and the cube's location\n         //  since based on time, the intervals are more even\n         if (time % 5 < 0.02) {\n            cubes.push(makeShape(geometry, colour, [Math.random()*5, Math.random()*2.5]))\n         }\n         else if (time % 4 < 0.02) {\n            cubes.push(makeShape(geometry, colour, [Math.random()*-5, Math.random()*-2.5]))\n         }\n         else if (time % 3 < 0.02) {\n            cubes.push(makeShape(geometry, colour, [Math.random()*-5, Math.random()*2.5]))\n         }\n         else if (time % 2 < 0.02) {\n            cubes.push(makeShape(geometry, colour, [Math.random()*5, Math.random()*-2.5]))\n         }\n         \n      // option 2:\n         // since this is truly random, intervals can be uneven\n         /*\n         var random = Math.random() / 1.5;\n         if (random < 0.001) {\n            cubes.push(makeShape(geometry, colour, [Math.random()*5, Math.random()*2.5]));\n         }\n         else if (random > 0.001 && Math.random() < 0.002) {\n            cubes.push(makeShape(geometry, colour, [Math.random()*-5, Math.random()*-2.5]));\n         }\n         else if (random > 0.002 && Math.random() < 0.003) {\n            cubes.push(makeShape(geometry, colour, [Math.random()*-5, Math.random()*2.5]))\n         }\n         else if (random > 0.003 && Math.random() < 0.004) {\n            cubes.push(makeShape(geometry, colour, [Math.random()*5, Math.random()*-2.5]))\n         }\n         */\n         \n\n         // this sets the speed of each cube (because we're translating it by a bit\n         //  in each frame)\n         cubes.forEach((cube, index) => {  // => is just a way to shorten the syntax\n            \n            // speed is randomly chosen from the array of possible speeds\n            cube.translateZ(speeds[Math.floor(Math.random()*8)]);\n         });\n\n         // setting up raycaster and finding intersections (where mouse vector intersects with box)\n      raycaster.setFromCamera( mouse, camera );\n         const intersects = raycaster.intersectObjects(scene.children);\n\n         console.log(intersects);\n\n         if (intersects.length > 0) {\n            // when mouse is over the box, it lights up and is removed from scene\n            if (intersectedBox != intersects[0].object ) {\n                  intersectedBox = intersects[ 0 ].object;\n                  // box lights up\n                  intersectedBox.material.emissive.setHex(0xff0000);\n                  intersectedBox.currentHex = intersectedBox.material.emissive.getHex();\n                  intersectedBox.material.color.setHex(0xFFFFFF);\n                  // after 15ms, box is removed from scene\n                  setTimeout(() => { scene.remove(intersectedBox); }, 15);\n                  // increase points by 10\n                  points += 10;\n                  console.log(points);\n            }\n\n         } else {\n            if ( intersectedBox ) intersectedBox.material.emissive.setHex( intersectedBox.currentHex );\n            // set intersected box to null\n            intersectedBox = null;\n         }\n         \n         //printPoints(points);\n\n         // this actually draws the scene\n         renderer.render(scene, camera);\n         \n         requestAnimationFrame(render);\n      }\n      requestAnimationFrame(render);\n   }\n   main();     \n    return (\n      <div>\n         <h1>Box Ninja | Game Page</h1>\n      </div>\n    );\n}\n \nexport default Game;"]},"metadata":{},"sourceType":"module"}